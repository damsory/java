복습

1.변수
 -변수를 선언할 수 있다.
 -변수 선언 방법
    자료형 변수명 =초기값;
 -자료형 종류
  -정수
   =byte,short,int,long
  -실수
   =float,double
  -문자
   =char
  -논리
   =boolean
 -변수명 작성 규칙
   숫자가 첫 글자로 올 수 없다.
   중복 선언이 불가능하다
   대소문자를 구별한다
   특수문자는 _와 $만 가능하다.공백도 불가능
   예약어(키워드)를 사용할 수 없다.
 -변수명 작성 관례
   카멜 표기법
    =변수명은 소문자로 작성
    =여러 영어 단어로 된 경우 두번째 단어부터 첫글자만 대문자로 작성
   변수명은 의미있게 작성
   상수는 대문자로 작성,여러 단어인 경우 _로 구분	
 -자료형변환
   변수나 값의 자료형을 일시적으로 변환하는 것
   자동 형변환(묵시적)
    =형변환을 직접 하지 않아도 자동으로 변환
    =작은 크기의 자료형을 큰 키기의 자료형에 저장하거나 연산하는 경우
	long num =1;
	1이라는 int형을 long로 변환하여 저장
    =정수를 실수로 변환
	double num =1;
	1이라는 int 정수형을 double 실수형으로 변환하여 저장
   강제 형변환(명시적)
    =반드시 형변환 표시를 해줘야 함
	(바꾸려는 자료형)
    =큰 크기의 자료형을 작은 크기의 자료형에 저장하거나 연산하는 경우
	int num =(int)1L;
	1L이라는 long형을 int로 변환하여 저장할때, (int)를 반드시 붙여야 함
    =실수를 정수로 변환
	int num =(int)3.14;
	3.14라는 double 실수형을 int 정수형으로 변환하여 저장할 때,(int)를 반드시 붙여햐함.
    =필요에 의해 형변환
	나누기 할 때 정수/정수는 결과가 정수가 되어서 소수점이 사라지는 현상을 막기위해
	형변환을 함
    =1/2=>0이 되기 때문에 1/(double)2 를 해서 0.5가 나오도록 할 때 사용
2.연산자
 -연산자 종류를 알고 결과를 예측할 수 있다.
 - 대입연산자
	=
	오른쪽 값을 왼쪽에 저장
	   왼쪽에는 변수만 올 수 있다
	비교연산자 == 와 구분
 -산술 연산자
	+,-,*,/,%
	결과가 특정 값
	정수 산술 연산자 정수=>정수
	    1/2=>0
	나누기 할 때 조심
 	%:나머지 연산자
 -논리 연산자
	&& ,||, !
	결과가 참 또는 거짓 (조건식,반복문에 많이 쓰임)
	&&
	~하고 ,~이고
	둘다 참이면 참 나머지는 거짓
	||
	~이거나 
	둘다 거짓이면 거짓 나머지는 참
	!
	반대
 -비교 연산자
	<, > ,<= ,>= ,== ,!=
	결과가 참 또는 거짓 (조건식,반복문에 많이 쓰임)
	==와 =을 구분
 -증감 연산자
	++,--
	최종적으로 1증가 또는 1감소
	전위형
	   변수 앞에 배치
	    증가/감소하고 동작
	후위형
	   변수 뒤에 배치
	   동작하고 증가/감소
 -조건 선택 연산자
	조건식 ? 참 :거짓
	조건이 참일 때 참을 가져오고,거짓일때 거짓을 가져옴
	조건문으로 대체가 가능
	이 연산자를 이용하면 코드가 간결해지는 경우가 있어서 알아두면 편함
 -비트 연산자[몰라도 크게 지장 없음]
	비트를 이용한 연산자
	&,|,~,^
	>>,<<,>>>
	
3.조건문
 -조건문을 이용하여 다양한 상황을 처리할 수 있다.
 -~이면 ...한다
 	~:조건식
	... :실행문
 -if문
	모든 조건문은 if문으로 표현 가능
	문법
	if(조건식1) {     //조건식1이 참이면 실행문1 실행
	  실행문1
	}else if(조건식2){  조건식1이 거짓이면 조건식2 실행
	  실행문2
	}else {
	  실행문3;
	}
	else if와 else은 없을 수도 있다
	else if는 여러개 올 수 있다
	if는 무조건 있어야 함
	if는 ~하면,else는 else 위에 모든 조건식이 거짓이면으로 해석
 -switch문
	일부 조건문을 이용할 때 사용
	문법
	switch(변수){
	case 값1:
	    실행문1;
	    break;
	case 값2:
	    실행문2;
	    break;
	default:
	    실행문3;
	}
	break는 switch문을 빠져 나가는 역할
	break는 생략될 수 있다

4.반복문
 -규칙적인 작업을 할 때 반복문을 이용할 수 있다
 -for문
	문법
	 for(초기화;조건식;증감식) {
	     실행문;
	}
	초기화
	    조건식,증감식,실행문에서 사용하는 변수들을 초기화 할 수 있다
	    ,를 이용하여 여러 변수를 초기화 할 수 있다
	    변수 선언도 가능하다
	    변수를 선언하고 다른 변수를 초기화 할 수 없다
	    생략 가능
	조건식
	    반복문을 실행할지 말지를 결정하는 곳
	    처음 거짓이 되는 순간 반복문을 종료
	    생략 가능
	    생략하면 true가 됨
	증감식
	    주로 조건식에서 사용하는 변수를 증가하거나 감소시켜 반복 횟수를 조절할 때 사용
	    생략 가능
	증감식,조건식,초기화를 이용하여 반복 횟수를 결정
 -while문
	문법
	while(조건식) {
	   실행문;
	}
	조건식
	    생략할 수 없음
	    역할은 for문의 조건식과 같음
 -do while문
	문법
	do{
	    실행문;
	}while(조건식);
	무조건 1번은 실행
	조건식
	     생략할 수 없음
	     역할은 for문의 조건식과 같음
 -향상된 for문
	문법
	for(자료형 변수명:컬렉션이나 배열){
	    실행문;
	}
	컬렉션이나 배열에 있는 값들을 하나씩 꺼내서 확인할 때 사용
			
5.배열
 -같은 타입의 값들을 관리할 때 배열을 이용할 수 있다.
 -컬렉션을 이용하면 배열보다 더 편하게 사용할 수 있다.
 -(같은 의미)같은 자료형의 데이터를 여러 개 관리할 때 배열을 사용
 -배열 생성
	자료형 배열명 [] =new 자료형[크기];
	자료형 [] 배열명 = new 자료형[크기];
 -배열 초기화
	자료형 배열명 [] =new 자료형[] {값1,값2,....};
	자료형 배열명 [] = {값1,값2,.....};
	배열명 =new 자료형[]{값1,값2,.....}; //가능
	배열명 ={값1,값2,.....};//불가능
-배열은 0번지 시작
-배열의 크기
	배열명.length를 통해 배열의 크기를 알 수 있다.
-배열의 사용
	배열명[번지]를 이용하여 변수처럼 사용할 수 있다
6.클래스
 -현실의 정보를 클래스로 선언할 수 있다.
 -클래스를 이용하여 프로그램을 작성할 수 있다
	
 -추상화
	현실의 정보를 클래스로 만드는 것
 -클래스
	현실의 정보를 코드로 구현한 것
 -클래스를 왜 쓸까?
	하나의 정보를 나타내는 여러 변수들을 따로 관리하면 불편하기 때문에 묶어서 하나의 
	클래스로 만들어서 사용
 -구성
	맴버 변수
	     클래스를 구성하는 정보
	     일반적으로 접근제어자를 private 설정 후 getter/setter를 추가
 	     A는B를 가지고 있다로 표현 가능한 경우,B는 A 클래스의 맴버변수가 된다.(has a 관계)
 -매서드
	클래스에서 제공하는 기능
	문법
	[접근제어자] [final] [static] 리턴타입 매서드명(매개변수들){
	     구현;
	}
	매개변수
	    매서드를 실행하기 위해 반드시 필요한 정보
	    없을 수도 있다
	리턴타입
	    기능 실행 후 알려줘야 하는 값들의 자료형
 -생성자
	객체를 생성한 후 생성자를 호출
	맴버 변수들을 초기화를 함
	문법
	접근제어자 클래스명(매개변수){
	 초기화;
	}
	접근제어자는 일반적으로 public 
	매개변수가 없으면 기본생성자
	생성자 오버로딩을 이용하여 다양한 생성자를 만들 수 있다.
 -객체 생성 및 사용
	클래스명 객체명 =new 클래스명();
	객체명.맴버변수1 =값;
	객체명.매서드();
 -접근제어자
	private
	   본인 클래스만 사용 가능
	default
	   본인 클래스+같은 패키지 클래스만 사용 가능
	protected
	    본인 클래스+같은 패키지+자식 클래스만 사용 가능
	public
	    모두 사용 가능
 -this
	본인 스스로를 가르키는 예약어
	주로 생성자나 매서드에서 매개변수명과 맴버변수 명이 같은 경우 this를 반드시 사용
 -this()
	본인 생성자 중 다른 생성자를 호출
 -static
	같은 클래스의 모든 객체들이 공유하는 맴버 변수나 매서드에 붙임
	static이 붙은 맴버변수나 매서드는 클래스가 메모리에 올라가면 생성
	호출은 클래스명을 통해 호출
	클래스명.맴버변수;
	클래스명.매서드();
 -맴버변수 초기화 순서
	기본값
	명시적 초기화
	초기화 블록
	생성자
	class A{
	  int num1; //기본값으로 초기화
	  int num2=1; //명시적 초기화
 	  int num3;
	{
	  num3=2;  //초기화 블록
	}
	 int num4;
	public A(){
	  num4 =3; //생성자
	}
          }

	

7.상속
 -클래스를 상속 받아 자식 클래스를 생성하여 활용할 수 있다.
 -클래스의 상속은 단일 상속
 -클래스 상속
 	부모 클래스의 맴버변수와 매서드를 물려 받는 것
 -extends 키워드를 이용
 - 매서드 오버라이딩
	부모 클래스에게 물려 받은 매서드를 재정의 하는 것
	리턴타입,매개변수,매서드명이 모두 동일
	접근제어자는 범위가 넓어지는 것 가능 좁히는 건 불가능
-클래스 형변환
	상속관계인 두 클래스에서 형변환을 할 수 있다
	업캐스팅
	     자식 클래스의 객체를 부모 클래스의 객체에 저장
	     항상 가능
	다운캐스팅
	     부모 클래스의 객체를 자식 클래스의 객체에 저장해서 활용
	     조건부로 가능
	     업 캐스팅된 객체를 다시 다운 캐스팅 하는 경우만 가능
 -instanceof
	형변환이 가능한지 알려주는 연산자
 -다형성
	클래스 형변환을 통해서 한 객체에 여러 종류의 객체가 오는 것
	

8.추상클래스
 -추상 클래스를 이해 할 수 있다.
 -구체적이지 않은 클래스 => 구현이 다 안된 클래스
 -abstract 키워드를 이용
 -추상 클래스는 반드시 추상 매서드를 가진다.(x)
 -추상매서드
	구현이 되지 않은 매서드
 	선언부만 있는 매서드
 - 추상 클래스를 이용하여 객체를 만들수 있다(x)
	상속을 통해 오버라이딩 해서 자식 클래스를 이용하여 객체를 생성
 -final
	변수
	   상수
	매서드
	    오버라이딩이 불가능
	클래스
	     부모 클래스가 될 수 없음
	     String

9.인터페이스
 -추상 매서드(디폴트 매서드)와 클래스 상수로만 이루어진 것
 -클래스가 어떤 기능을 제공하는지 알려주기 위해 사용
 -인터페이스 상속은 다중 상속
 -구현 클래스
 	인터페이스의 객체를 만들려면 구현 클래스가 있어야 한다
 	implements 키워드를 이용
	구현 클래스는 인터페이스의 추상 매서드들을 반드시 오버라이딩 해야 함
	
10.기본 클래스
 -Object 클래스
	최상위 조상 클래스
	모든 클래스는 Object 클래스가 제공하는 매서드를 사용할 수 있다.
	오버라이딩을 통해 재정의 할 수 있다.
	toString(), equals() 를 주로 오버라이딩 함
 -String 클래스
	문자열 클래스
	문자열을 쉽게 사용할 수 있는 매서드를 제공
	매서드
	        equals():두 문자열이 같은 지를 비교
	        substring() :부분 문자열 생성
	        compareTo():문자열을 비교하여 사전순으로 앞이면 음수,같으면 0,뒤면
 			양수를 반환, 주로 문자열을 이용하여 정렬할 때 사용
	        split() :문자열을 토큰을 기준으로 추출하여 배열로 반환
 -Pattern 클래스
	정규표현식을 확인할 때 사용하는 클래스
 -Wrapper 클래스
	기본 자료형을 클래스로 만든 것
	목적은 제네릭클래스에서 사용하기 위해
	클래스,parse클래스(문자열)을 통해 문자열을 각 클래스 타입으로 바꿔줌
	    integer.parselnt("123")은 문자열 123을 정수 123으로 변환
 -Date 클래스
	날짜를 관리하는 클래스
	simpleDateFormat 클래스 을 이용하여 날짜를 문자열로,문자열을 날짜로 변환해서 사용


11.예외 처리
 -프로그램에서 문제가 발생하여 프로그램이 중단되는 경우를 예외처리를 통해 해결할 수 있다.
 -직접 처리
	try catch를 이용
	try{
	 에러가 발생할 수 있는 코드;
	}catch(예외클래스 e) {
	   예외 처리;
	}
 -예외 던지기
	throw와 throws를 이용
	RuntimeException 클래스이거나 자식 클래스이면 throws를 생략할 수 있다
	리턴타입 매서드명(매개변수) throws 예외클래스{
	if(조건){
	   throw new 예외클래스();
	  }
	}

	

12.제네릭
 -라이브러리에서 제공하는 제네릭 클래스와 인터페이스를 사용할 수 있다.
 -맴버변수 또는 매서드의 타입이 정해지지 않은 클래스/인터페이스
 -객체를 생성할 때 타입이 정해짐
 -타입으로는 클래스만 올 수 있다. => 기본 자료형은 올 수 없다. => Wrapper 클래스를 이용
 -제네릭 클래스 객체 생성
	클래스명<타입> 객체명 =new 클래스명<타입>();


13.컬렉션 프레임워크
 -컬렉션과 맵에서 제공하는 매서드를 사용할 수 있다.
 -컬렉션 프레임워크는 컬렉션 +맵
 -Collection 인터페이스
	한 종류의 값을 관리
	List 인터페이스
	    순서 보장 중복 가능
	    번지를 통해 접근 가능
	    ArrayList, LinkedList
	Set  인터페이스
	    순서 보장 x 중복 불가능
	    번지를 통해 접근이 불가능	    
	     HashSet, TreeSet
-Map 인터페이스
	두 종류의 값을 관리
	   Key, Value
	   Key 중복 불가능
	   Value 중복 불가능


14.람다식


15.스트림


16.자바입출력


17.쓰레드


18.네트워크


용어 정리
-상수
   변수 앞에 final이 붙어 있으면 상수
   이름이 있는 리터럴이라고 생각하면 편함
-리터럴
   1,2,'a',3.14,"문자열"등과 같이 직접적인 값



